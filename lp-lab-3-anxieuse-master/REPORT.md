# Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Короткевич Л. В. 

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В.     |              |               |
| Левинская М.А.    |              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В задачах, где условие можно представить в виде структуры состояний и требуется что-либо найти, удобно применить методы поиска в пространстве состояний. Мы можем представить состояния и переходы между ними в виде графа и таким, образом свести задачу к анализу структуры графа.

В таких задачах удобно воспользоваться прологом, так как работа с графами в прологе более удобна чем в некоторых классических языках программирования. Мы задаем граф предикатами, в отличие от написания различных структур данных в классических языках программирования.

## Задание

Вариант 8:

Вдоль доски расположены лунки, в каждой из которых лежит красный, белый или синий шар. Одним ходом можно менять местами два любых шара. Добиться того, чтобы сначала шли все красные шары, все синие - последними, а белые - посередине. Решить задачу за наименьшее число ходов.

## Принцип решения

Для решения задачи первое, что необходимо сделать - это задать представление графа или, что то же самое, написать предикат перехода из одного состояния в другое. Чтобы написать переход состояний, необходимо перебрать варианты перестановки любых двух элементов списка, но при этом, так как у нас есть точно заданный порядок, можно отсечь заранее бессмысленные перестановки двух элементов списка.

Предикат перехода из одного состояния в другое move:
```
less(r, w).
less(w, b).
less(r, b).

permute([], []).
permute([X|Rest], L) :-
    permute(Rest, L1),
    select(X, L, L1).

check([A, B]) :-
    less(B, A).

check_length(A, B) :-
    length(A, Al), length(B, BL),
    Al < 2, BL < 2.

move(A, B) :- move(A, B, [], []).
    
move([], [], A, B) :-
    length(A, 2), length(B, 2),
    permute(A, B),
    not(A = B),
    check(B).
move([X|T], [X|R], A, B) :-
    move(T, R, A, B).
move([X|T], [Y|R], A, B) :-
    check_length(A, B),
    move(T, R, [X|A], [Y|B]).
```

Далее нам просто необходимо запустить поиск в ширину для нахождения самого "короткого" решения.

Поиск в  ширину:
```
prolong([X|T], [Y, X|T]) :-
    move(X, Y), not(member(Y, [X|T])).

bdth([[X|T]|_], X, [X|T]).
bdth([P|Q1], X, R) :-
	findall(Z, prolong(P, Z), T),
	append(Q1, T, Q0), !,
	bdth(Q0, X, R).
bdth([_|T], Y, R) :-
	bdth(T, Y, R).

search_bdth(X, Y, P) :-
	bdth([[X]], Y, L), reverse(L, P).
```
Поиск в  глубину:
```
dpth([X|T], X, [X|T]).
dpth(P, F, L) :-
    prolong(P, P1), dpth(P1, F, L).

search_dpth(A, B, P) :-
    dpth([A], B, L), reverse(L, P).
```
Поиск с итерационным заглублением:
```
depth_id([Finish|T], Finish, [Finish|T], 0).
depth_id(Path, Finish, R, N) :-
    N > 0,
    prolong(Path, NewPath),
    N1 is N - 1,
    depth_id(NewPath, Finish, R, N1).

search_id(Start, Finish, Path, DepthLimit) :-
    depth_id([Start], Finish, Res, DepthLimit),
    reverse(Res, Path).
```
## Результаты

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|------------------|
| В глубину       |             5                  | 0.00124507172364977|
| В ширину        |             4                  | 3.58172673748199001|
| ID              |             4                  | 0.07599102938477701|

## Выводы

В данной лабораторной работе для решения поставленной задачи использовался метод поиска в пространстве состояний. Были использованы три поиска. Очевидно, что для данной задачи самым оптимальным алгоритмом поиска является поиск в ширину, так как нам необходимо найти самый короткий путь в графе состояний, но также мы могли бы задать граф иначе, чтобы поиск в глубину выдавал первым решением самый короткий путь. Но этот путь на мой взгляд сложнее, так как тут задача ставится в построении графа. По скорости поиск в ширину уступает алгоритму поиска в глубину и алгоритму поиска с итерационным заглублением. Также стоит отметить, что поиск с итерационным заглублением дал такой же ответ, как и поиск в ширину, но при правильном лимите. В итоге при нахождении одного наикратчайшего решения, приемлемым алгоритмом будет алгоритм поиска в ширину; но при поиске любого пути лучше использовать поиск в ширину, так как он работает быстрее.
