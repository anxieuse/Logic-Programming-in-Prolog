# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Короткевич Л. В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры
данных в традиционных языках похожи списки в Прологе?

## Задание 1.1: Предикат обработки списка

`ff(X,List,Res)` - находит позицию первого вхождения X в списке List
`ff_std(X,List,Res)` - находит позицию первого вхождения X в списке List без использования стандартных предикатов

Примеры использования:
```prolog
?- ff(1,[],R).
false.

?- ff(1,[2],R).
false.

?- ff(1,[2,1,3,1],R).
R = 1.

?- ff_std(1,[],R).
false.

?- ff_std(1,[2],R).
false.

?- ff_std(1,[2,1,3,1,1,1,1,1,1,2],R).
R = 1.
```

Реализация:
```prolog
ff(X, [X|_], 0) :- !.
    ff(X, [_|T], N) :-
        leo_member(X, T),
        ff(X, T, N1),
        N is N1 + 1,
        !.
ff_std(X, T, N) :-
        append(L, [X|T1], T),
        length(L, N),
        !.
```

Описание работы ff: идем по списку, пока не встретим элемент X. Каждую итерацию увеличиваем счетчик N на один и, соответственно, "урезаем" исходный список на один элемент слева.

Описание работы ff_std: делим список на две части: левую, X не содержащую вообще, и правую, с него начинающуюся. Ответ - длина первой части исходного списка.

## Задание 1.2: Предикат обработки числового списка

`sum([X|T], R)` - считаем сумму элементов списка с помощью одного метода рекурсии
`sum_std([X|T], R)` - считаем сумму элементов списка с помощью другого метода рекурсии

Примеры использования:
```prolog
?- sum([],R).
R = 0.

?- sum([1],R).
R = 1.

?- sum([1,-1,2,-2,1000],R).
R = 1000.

?- sumstd([],R).
R = 0.

?- sumstd([1],R).
R = 1.

?- sumstd([1,-1,2,-2,1000],R).
R = 1000.
```

Реализация:
```prolog
sum([], 0).
sum([X|T], R) :-
        sum(T, R1),
        R is R1 + X.
sumstd(L,R) :-
        sumstd(L,0,R).
sumstd([],F,F).
sumstd([H|T],F,R) :-
        F2 is F+H,
        sumstd(T,F2,R).
```

Описание работы sum: итерационно идем по списку, складывая каждый встречный элемент в R и рекурсивно вызывая функцию со списком на элемент меньше и промежуточной переменной R1. 

Описание работы sumstd: аналогично предыдущему, идем по списку и совершаем почти те же действия; разве что, вспомогательная переменная F2 здесь фигурирует в другом месте. Она отвечает за "промежуточную" сумму. R же, в свою очередь, примет значение оной в самом конце, когда список окажется пуст.

## Задание 2: Реляционное представление данных

В реляционной модели данных объекты и взаимосвязи между ними представляются с помощью таблиц. 
Взаимосвязи рассматриваются в качестве объектов.

Преимущества реляционного представления:

* удобное для пользователя представление объектов в виде таблиц
* возможность использования непроцедурных языков для работы 
* основа модели - математический аппарат, который позволяется строго описывать операции над данными
* независимость данных

Недостатки реляционного представления:

* не все необходимые для описания сферы можно представить в виде таблиц
* большой расход памяти для представления
* низкая скорость при выполнении операции соединения

Преимущества представления в four.pl:

* независимость отдельных компонентов программы, служащих для ответа на те или иные запросы...
* ...что позволяет тестировать программу "на лету", по мере написания новых предикатов

Недостатки представления в four.pl:
* факты об оценках в структурах
* неудобно обращаться со списками
* факты со списками групп оказались почти бесполезны

Предикаты реализованные для работы с four.pl:
* sub_to_avg(Subj,Avg) - средняя оценка по предмету
* sub_to_grades(L1, L2) - список всех оценок по всем предметам
* remove_same(L,L1) - удаление повторяющихся значений оценок у некоторого студента
* group_to_cnt(GR,COUNT) - количество несдавших студентов в группе
* grades_to_bad_cnt(L,C) - по списку оценок определим число несдавших
* sub_to_bad_cnt(Sub,Count) - число несдавших опред. предмет

1 задание: Напечатать средний балл для каждого предмета.

`sub_to_avg(Subj,Avg)` - печатает средний балл для заданного предмета.

Примеры использования:
```prolog
?- sub_to_avg(Subj,Avg).
Subj = 'Логическое программирование',
Avg = 4.107142857142857 ;
Subj = 'Математический анализ',
Avg = 4.035714285714286 ;
Subj = 'Функциональное программирование',
Avg = 4.107142857142857 ;
```

Реализация:
```prolog
% список оценок -> сумма
grades_to_sum([],0).
grades_to_sum([grade(X,Y)|T],N):- grades_to_sum(T,M), N is Y + M.

% предмет -> среднее 
sub_to_avg(Sub,Avg):-
    subject(Sub,Y),
    grades_to_sum(Y, Sum),
    length(Y, Len),
    Avg is Sum / Len.
```
Сначала получаем список всех оценок по предмету, затем подсчитываем сумму всех баллов по этому предмету, потом считаем срадний балл (сумму делим на количество оценок).

2 задание: Для каждой группы, найти количество несдавших студентов.

`group_to_cnt(Gr,Count)` - находит количество несдавших студентов в заданной группе

Примеры использования:
```prolog
?- group_to_cnt(101,X).
X = 3 .

?- group_to_cnt(102,X).
X = 3 .

?- group_to_cnt(103,X).
X = 2 .

?- group_to_cnt(104,X).
X = 2 .
```

Реализация:
```prolog
% список всех оценок по всем предметам
sub_to_grades([],L).
sub_to_grades([H|T], List_pass):-subject(H,X), sub_to_grades(T, New_list), append(X, New_list, List_pass).

% удаление повторяющихся значений оценок
remove_same_grades(_,[],[]).
remove_same_grades(X,[X|L],L1):-remove_same_grades(X,L,L1).
remove_same_grades(X,[Y|L],[Y|L1]):- X \= Y, remove_same_grades(X,L,L1).

remove_same([],[]).
remove_same([H|T],[H|T1]):-remove_same_grades(H,T,T2), remove_same(T2,T1).

% список -> число в необх. группе
cnt([],L,0).
cnt([grade(X,Y)|T],L,N):- Y < 3, member(X, L), !, cnt(T,L,M), N is M + 1.
cnt([_|T],L,N):-cnt(T,L,N).

% группа -> число несдавших
group_to_cnt(Gr,Count):-
    group(Gr, Lgroup),
    findall(Sub, subject(Sub,_), Subs),
    sub_to_grades(Subs, List_pass),
    remove_same(List_pass, New),
    cnt(New, Lgroup, Count).
```
Получаем список студентов нужной группы, получаем список всех возможных предметов, получаем все оценки по всем предметам, удаляем повторяющиеся оценки, чтобы если один и тот же студент не сдал больше 1 предмета, не считать его дважды, проверяем сколько из несдавших студентов являются студентами заданной группы.

3 задание: Найти количество несдавших студентов для каждого из предметов.

`sub_to_bad_cnt(Sub,Count)` - находит число несдавших определенный предмет

Примеры использования:
```prolog
?- sub_to_bad_cnt(X,Y).
X = 'Логическое программирование',
Y = 3 ;
X = 'Математический анализ',
Y = 1 ;
X = 'Функциональное программирование',
Y = 0 
...
```

Реализация:
```prolog
% по списку выдает искомое кол-во несдавших
grades_to_bad_cnt([],0).
grades_to_bad_cnt([grade(X,Y)|T],N):- Y < 3, !, grades_to_bad_cnt(T,M), N is M + 1.
grades_to_bad_cnt([_|T],N):-grades_to_bad_cnt(T,N).

% предмет -> число студентов
sub_to_bad_cnt(Sub,Count):-
    subject(Sub,Y),
    grades_to_bad_cnt(Y,Count).
```
Получаем список оценок по нужному предмету, считаем сколько из них двоек.

## Выводы

В лабораторной работе прошло знакомство с языком Prolog и компилятором GNU Prolog. Были написаны предикаты обработки списков и числовых списков со стандартными и без стандартных предикатов. Так же были реализованы запросы к реляционному представлению данных.<br>

Prolog является декларативным языком программирования, это был первый подобный опыт, т.к. приходится работать только с императивными языками(С, С++, Python). Интересно то, что в Prolog нет циклов и всё реализуется через обычную рекурсию.<br>

При программировании на Prolog усилия программиста должны быть направлены на описание логической модели фрагмента предметной области решаемой задачи в терминах объектов предметной области, их свойств и отношений между собой, а не деталей программной реализации. Фактически Prolog представляет собой не столько язык для программирования, сколько язык для описания данных и логики их обработки.<br>

Основные области применения Prolog:

* быстрая разработка прототипов прикладных программ;
* автоматический перевод с одного языка на другой;
* создание естественно-языковых интерфейсов для существующих систем;
* символьные вычисления для решения уравнений, дифференцирования и интегрирования;
* проектирование динамических реляционных баз данных;
* экспертные системы и оболочки экспертных систем;
* автоматизированное управление производственными процессами;
* автоматическое доказательство теорем;
* полуавтоматическое составление расписаний;
* системы автоматизированного проектирования, базирующееся на знаниях программное обеспечение;
* организация сервера данных или, точнее, сервера знаний, к которому может обращаться клиентское приложение, написанное на каком-либо языке программирования.<br>

Недостатком языка является его непопулярность. По индексу TIOBE, Prolog занимает  лишь 30 место. Более того, я счиатаю, что обработка данных с помощью привычных нам языков более простая и удобная.<br>
