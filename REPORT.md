# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Короткевич Л. В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры
данных в традиционных языках похожи списки в Прологе?

## Задание 1.1: Предикат обработки списка

`ff(X,List,Res)` - находит позицию первого вхождения X в списке List
`ff_std(X,List,Res)` - находит позицию первого вхождения X в списке List без использования стандартных предикатов

Примеры использования:
```prolog
?- ff(1,[],R).
false.

?- ff(1,[2],R).
false.

?- ff(1,[2,1,3,1],R).
R = 1.

?- ff_std(1,[],R).
false.

?- ff_std(1,[2],R).
false.

?- ff_std(1,[2,1,3,1,1,1,1,1,1,2],R).
R = 1.
```

Реализация:
```prolog
ff(X, [X|_], 0) :- !.
    ff(X, [_|T], N) :-
        leo_member(X, T),
        ff(X, T, N1),
        N is N1 + 1,
        !.
ff_std(X, T, N) :-
        append(L, [X|T1], T),
        length(L, N),
        !.
```

Описание работы ff: идем по списку, пока не встретим элемент X. Каждую итерацию увеличиваем счетчик N на один и, соответственно, "урезаем" исходный список на один элемент слева.

Описание работы ff_std: делим список на две части: левую, X не содержащую вообще, и правую, с него начинающуюся. Ответ - длина первой части исходного списка.

## Задание 1.2: Предикат обработки числового списка

`sum([X|T], R)` - считаем сумму элементов списка с помощью одного метода рекурсии
`sum_std([X|T], R)` - считаем сумму элементов списка с помощью другого метода рекурсии

Примеры использования:
```prolog
?- sum([],R).
R = 0.

?- sum([1],R).
R = 1.

?- sum([1,-1,2,-2,1000],R).
R = 1000.

?- sumstd([],R).
R = 0.

?- sumstd([1],R).
R = 1.

?- sumstd([1,-1,2,-2,1000],R).
R = 1000.
```

Реализация:
```prolog
sum([], 0).
sum([X|T], R) :-
        sum(T, R1),
        R is R1 + X.
sumstd(L,R) :-
        sumstd(L,0,R).
sumstd([],F,F).
sumstd([H|T],F,R) :-
        F2 is F+H,
        sumstd(T,F2,R).
```

Описание работы sum: итерационно идем по списку, складывая каждый встречный элемент в R и рекурсивно вызывая функцию со списком на элемент меньше и промежуточной переменной R1. 

Описание работы sumstd: аналогично предыдущему, идем по списку и совершаем почти те же действия; разве что, вспомогательная переменная F2 здесь фигурирует в другом месте. Она отвечает за "промежуточную" сумму. R же, в свою очередь, примет значение оной в самом конце, когда список окажется пуст.

## Задание 2: Реляционное представление данных

В реляционной модели данных объекты и взаимосвязи между ними представляются с помощью таблиц. 
Взаимосвязи рассматриваются в качестве объектов.

Преимущества реляционного представления:

* удобное для пользователя представление объектов в виде таблиц
* возможность использования непроцедурных языков для работы 
* основа модели - математический аппарат, который позволяется строго описывать операции над данными
* независимость данных

Недостатки реляционного представления:

* не все необходимые для описания сферы можно представить в виде таблиц
* большой расход памяти для представления
* низкая скорость при выполнении операции соединения

Преимущества представления в four.pl:

* независимость отдельных компонентов программы, служащих для ответа на те или иные запросы...
* ...что позволяет тестировать программу "на лету", по мере написания новых предикатов

Недостатки представления в four.pl:
* факты об оценках в структурах, что несколько затрудняет обращение со списками

Предикаты реализованные для работы с four.pl:
* sum([X|Y], S): Считает сумму. Используется для вычисления среднего.
* avg(L, R): Считает среднее. Используется для подсчета среднего.
* grades(Student, N): Выдает все оценки студента. 
* stud_to_overall_avg(Student, Res): Среднее по всем предметам, оценкам определенного студента.
* group_to_every_studs_avg(Group, Res): Средний балл каждого студента в определенной группе.
* groups_avg(): В каждой группе считаем сумму средних баллов всех ее студентов. Считаем среднее арифм. этой суммы. Выводим результат.
* subj_to_failed_studs(Subj, Name): Находит имена студентов, имеющих двойки по опред. предмету.
* subj_failed(): По каждому предмету выводит список несдавших его студентов, если такие имеются.
* group_subj_to_failed_studs(Group, Stud): Студенты с неудами в опред. группе.
* group_to_cnt_failed(Group, Cnt): Кол-во студентов с недуами в опред. группе.
* cnt_failed(): В каждой группе считает число студентов с неудами.

### 1 задание: Напечатать средний балл для каждого предмета.

`groups_avg()` - В каждой группе считаем сумму средних баллов всех ее студентов. Считаем среднее арифм. этой суммы. Выводим результат.

Примеры использования:
```prolog
?- groups_avg().
Группа №102, средний бал: 3.9444444444444446
Группа №101, средний бал: 3.9666666666666672
Группа №104, средний бал: 3.861111111111111
Группа №103, средний бал: 4.145833333333334
```

Реализация:
```prolog
% Считает сумму. Используется для вычисления среднего.
sum([], 0).
sum([X|Y], S) :-
    sum(Y, S1),
    S is S1 + X.

% Считает среднее. Используется для подсчета среднего.
avg(L, R) :-
    length(L, Len),
    sum(L, Sum),
    R is Sum / Len.

% Выдает оценки все студента. 
grades(Student, N) :-
    subject(_, X),
    member(grade(Student, N), X).

% Среднее по всем предметам, оценкам определенного студента.
stud_to_overall_avg(Student, Res) :-
    findall(N, grades(Student, N), List),
    avg(List, Res).

% Средний балл каждого студента в определенной группе.
group_to_every_studs_avg(Group, Res) :-
    group(Group, StudList),
    member(Stud, StudList),
    stud_to_overall_avg(Stud, Res).

% В каждой группе считаем сумму средних баллов всех ее студентов. Считаем среднее арифм. этой суммы. Выводим результат.
groups_avg() :-
    group(Group, _),
    findall(Res, group_to_every_studs_avg(Group, Res), ListValue),
    avg(ListValue, Ans),
    write('Группа №'), write(Group), write(', средний бал: '), write(Ans), write('\n'), fail.
```
Пробегаемся по списку каждой группы, считаем средний балл каждого из ее студентов, считаем среднее арифм. средних баллов.

### 2 задание: Для каждой группы, найти количество несдавших студентов.

`subj_failed()` - По каждому предмету выводит список несдавших его студентов, если такие имеются.

Примеры использования:
```prolog
?- subj_failed().
Предмет "Логическое программирование" не сдали: [Петровский,Сидоров,Джаво]
Предмет "Математический анализ" не сдали: [Петров]
Предмет "Функциональное программирование" сдали все!
Предмет "Информатика" не сдали: [Сиплюсплюсов,Криптовалютников]
Предмет "Английский язык" не сдали: [Решетников,Азурин]
Предмет "Психология" не сдали: [Безумников,Круглосчиталкин]
```

Реализация:
```prolog
% Находит имена студентов, имеющих двойки по опред. предмету
subj_to_failed_studs(Subj, Name) :-
    subject(Subj, Students),
    member(grade(Name, 2), Students).

% По каждому предмету выводит список несдавших его студентов, если такие имеются.
subj_failed() :-
    subject(Subj, _),
    findall(Name, subj_to_failed_studs(Subj, Name), List),
    length(List, ListLen),
    write('Предмет "'), write(Subj), 
        ((ListLen \= 0, write('" не сдали: '), write(List), write('\n'));
        (ListLen == 0, write('" сдали все!\n'))),
        fail.
```
Пробегаемся по списку оценок каждого из предметов, находим проваливших его сдачу студентов, считаем их кол-во и выводим оное, если то не равно нулю.

### 3 задание: Найти количество несдавших студентов для каждого из предметов.

`cnt_failed()` - В каждой группе считает число студентов с неудами.

Примеры использования:
```prolog
?- cnt_failed().
Группа №102, число несдавших: 3
Группа №101, число несдавших: 3
Группа №104, число несдавших: 2
Группа №103, число несдавших: 2
```

Реализация:
```prolog
% Студенты с неудами в опред. группе.
group_subj_to_failed_studs(Group, Stud) :-
    subject(_, GradesList),
    group(Group, StudsList),
    member(Stud, StudsList),
    member(grade(Stud, 2), GradesList).

% Кол-во студентов с недуами в опред. группе.
group_to_cnt_failed(Group, Cnt) :-
    findall(Name, group_subj_to_failed_studs(Group, Name), List),
    length(List, Cnt).

% В каждой группе считает число студентов с неудами.
cnt_failed() :-
    group(Group, _),
    group_to_cnt_failed(Group, Cnt),
    write('Группа №'), write(Group), write(', число несдавших: '), write(Cnt), write('\n'), fail.
```
В каждой группе посчитаем число студентов с недуами и выведем его. 

## Выводы

Пролог - это описательный язык программирования, применяемый для решения задач, в коих действуют объекты и отношения между ними.

Ориентация Пролога – “нетрадиционные” использования вычислительной техники: распознавание естественного языка, базы знаний, экспертные системы и другие задачи.

Пролог, благодаря своим особенностям, используется в области искусственного интеллекта, компьютерной лингвистики и нечислового программирования в целом. В некоторых случаях реализация символьных вычислений на других стандартных языках вызывает необходимость создавать большое количество кода, сложного в понимании, в то время как реализация тех же алгоритмов на языке Пролог даёт простую программу, легко помещающуюся на одной странице.

Основные области применения Prolog:

* экспертные системы и оболочки экспертных систем
* быстрая разработка прототипов прикладных, автогенерация кода
* проектирование динамических рекурсивных БД и СУБД
* автоматическое доказательство теорем<br>

Недостатком языка является его непопулярность. По индексу TIOBE, Prolog занимает  лишь 30 место. Несмотря на то, что обработка данных с помощью привычных нам языков более простая и удобная.<br>

### Литература
  1. Пролог (язык программирования) / Материал из Википедии — свободной энциклопедии


