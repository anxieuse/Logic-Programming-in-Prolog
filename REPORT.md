# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Опишите своими словами, чем списки в языке Пролог отличаются от принятых в императивных языках подходов к хранению данных. На какие структуры
данных в традиционных языках похожи списки в Прологе?

## Задание 1.1: Предикат обработки списка

`ff(X,List,Res)` - находит позицию первого вхождения X в списке List
`ff_std(X,List,Res)` - находит позицию первого вхождения X в списке List без использования стандартных предикатов

Примеры использования:
```prolog
?- ff(1,[],R).
false.

?- ff(1,[2],R).
false.

?- ff(1,[2,1,3,1],R).
R = 1.

?- ff_std(1,[],R).
false.

?- ff_std(1,[2],R).
false.

?- ff_std(1,[2,1,3,1,1,1,1,1,1,2],R).
R = 1.
```

Реализация:
```prolog
ff(X, [X|_], 0) :- !.
    ff(X, [_|T], N) :-
        leo_member(X, T),
        ff(X, T, N1),
        N is N1 + 1,
        !.
ff_std(X, T, N) :-
        append(L, [X|T1], T),
        length(L, N),
        !.
```

Описание работы ff: идем по списку, пока не встретим элемент X. Каждую итерацию увеличиваем счетчик N на один и, соответственно, "урезаем" исходный список на один элемент слева.
Описание работы ff_std: делим список на две части: левую, X не содержащую вообще, и правую, с него начинающуюся. Ответ - длина первой части исходного списка.

## Задание 1.2: Предикат обработки числового списка

`sum([X|T], R)` - считаем сумму элементов списка с помощью одного метода рекурсии
`sum_std([X|T], R)` - считаем сумму элементов списка с помощью другого метода рекурсии

Примеры использования:
```prolog
?- sum([],R).
R = 0.

?- sum([1],R).
R = 1.

?- sum([1,-1,2,-2,1000],R).
R = 1000.

?- sumstd([],R).
R = 0.

?- sumstd([1],R).
R = 1.

?- sumstd([1,-1,2,-2,1000],R).
R = 1000.
```

Реализация:
```prolog
sum([], 0).
sum([X|T], R) :-
        sum(T, R1),
        R is R1 + X.
sumstd(L,R) :-
        sumstd(L,0,R).
sumstd([],F,F).
sumstd([H|T],F,R) :-
        F2 is F+H,
        sumstd(T,F2,R).
```

Описание работы sum: итерационно идем по списку, складывая каждый встречный элемент в R и рекурсивно вызывая функцию со списком на элемент меньше и промежуточной переменной R1. 
Описание работы sumstd: аналогично предыдущему, идем по списку и совершаем почти те же действия; разве что, вспомогательная переменная F2 здесь фигурирует в другом месте. Она отвечает за "промежуточную" сумму. R же, в свою очередь, примет значение оной в самом конце, когда список окажется пуст.

## Задание 2: Реляционное представление данных

В реляционной модели данных объекты и взаимосвязи между ними представляются с помощью таблиц. 
Взаимосвязи рассматриваются в качестве объектов.

Преимущества реляционного представления:

* удобное для пользователя представление объектов в виде таблиц
* возможность использования непроцедурных языков для работы 
* основа модели - математический аппарат, который позволяется строго описывать операции над данными
* независимость данных

Недостатки реляционного представления:

* не все необходимые для описания сферы можно представить в виде таблиц
* большой расход памяти для представления
* низкая скорость при выполнении операции соединения

Преимущества представления в four.pl:

* независимость отдельных компонентов программы, служащих для ответа на те или иные запросы...
* ...что позволяет тестировать программу "на лету", по мере написания новых предикатов

Недостатки представления в four.pl:
* факты об оценках в структурах
* неудобно обращаться со списками
* факты со списками групп оказались почти бесполезны

Предикаты реализованные для работы с four.pl:
(1) sub_to_avg(Subj,Avg) - средняя оценка по предмету
2) sub_to_grades(L1, L2) - список всех оценок по всем предметам
3) remove_same(L,L1) - удаление повторяющихся значений оценок у некоторого студента
4) group_to_cnt(GR,COUNT) - количество несдавших студентов в группе
5) grades_to_bad_cnt(L,C) - по списку оценок определим число несдавших
6) sub_to_bad_cnt(Sub,Count) - число несдавших опред. предмет



## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.




