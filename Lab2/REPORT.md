## Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Короткевич Л. В., М8О-208Б-19

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|           |              |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Существует несколько подходов к решению логических задач, относящихся к методам перебора. Одним из них является метод порождения и проверок. Суть данного метода такова: некоторый предикат множество исходных данных, которые далее обрабатываются другими предикатами на предмет соответствия условию задачи. В случае несоответствия выполняется возврат, подразумевающий генерацию новых исходных данных с дальнейшей их проверкой. В случае соответствия условий программа прекращает вычисления, так как задача считается решенной.

Еще одним подходом к решению логических задач является метод ветвей и границ. Этот подход предполагает отсечение заведомо неправильных решений, что значительно уменьшает количество переборов данных по сравнению с предыдущим методом. В остальном эти методы имеют общюю идею.

Prolog удобен для решения логических задач наличием в нем бэктрэкинга, который позволяет при каждой неудаче совершать откат и продолжать поиск в дереве вариантов. Еще одним достоинством данного языка логического программирования является то, что для описания условий задачи достаточно сформировать ряд предикатов, которые принимают значения ИСТИНА или ЛОЖЬ, что позволяет сразу отсекать неподходящие ветви.

## Задание

15. Корнеев, Докшин, Мареев и Скобелев жители нашего города. Их профессии пекарь, врач, инженер и милиционер. Корнеев и Докшин соседи и всегда на работу ездят вместе. Докшин старше Мареева. Корнеев регулярно обыгрывает Скобелева в пинг-понг. Пекарь на работу всегда ходит пешком. Милиционер не живет рядом с врачом. Инженер и милиционер встречались один-единственный раз, когда милиционер оштрафовал инженера за нарушение правил уличного движения. Милиционер старше врача и инженера. Определите, кто чем занимается.

## Принцип решения

Для решения задачи опишем все, что нам известно, используя предикаты.

В условии есть информация о соседях, поэтому опишем предикат, проверяющий, являются ли два элемента списка соседними. И пусть соседи будут расположены в начале списка.

```
neighboors(А,B,С) :- С=[А,B,_,_]; С=[B,А,_,_].
```
```
?- neighboors(X,Y,[1,2,3,4]).
X = 1,
Y = 2 ;
X = 2,
Y = 1.
```

Также в условии задачи сказано, что одна пара людей играет в пинг-понг. Будем полагать расположения этих людей равные 2 и 3 соответственно. 

```
play(А,B,С) :- С=[_,А,B,_];С=[_,B,А,_]. 
```
```
?- play(1,2,[0,2,1,4]).
true.
```

Не забудем про то, что факт соседства гарантирует факт "rides", означающий, что человек использует наземный транспорт. 

```
rides(А,С) :- neighboors(А,_,С).
```

Имеется также факт о единоразовой встрече двух персон. Базируясь на прошлых предикатах, опишем новый - "meetOnce":
```
meetOnce(А,B,С) :- not(neighboors(А,B,С)), not(play(А,B,С)).
```

Решение также будет включать в себя стандартные предикаты типа member, length. Сложность каждого из них, а также вышеописанных предикатов - O(N).

Основной предикат solve.

```
solve(С) :-                                      % список вида с(фамилия,профессия,возраст)
    length(С, 4),                                %  всего в списке 4 человека
    member(с(_,_,4), С),                         %  4 - самый старший, ..., 1 - самый младший  
    member(с(_,_,3), С),                         
    member(с(_,_,2), С),                         
    member(с(_,_,1), С),                         
    member(с(_,baker,_), С),                     %  есть 4 профессии    
    member(с(_,doctor,_), С),                    
    member(с(_,policeman,_), С),                 
    member(с(_,engineer,_), С),                  
    neighboors(с(korneev,_,_), с(dokshin,_,_), С),    % korneev и dokshin - neighboors
    rides(с(korneev,_,_),С),rides(с(dokshin,_,_), С), % они ездят на работу
    member(с(dokshin,_,DAGE), С), member(с(mareev,_,MAGE), С), DAGE>MAGE, % возраст dokshin > mareev
    play(с(korneev,_,_),с(skobelev,_,_),С), % игроки в пинг-понг
    not(rides(с(_,baker,_),С)),             % baker ходит пешком (не катается)
    not(neighboors(с(_,policeman,_), с(_,doctor,_), С)),        % policeman не живет рядом с doctor (не соседи)
    meetOnce(с(_,engineer,_), с(_,policeman,_), С), % engineer и policeman встречались 1 раз 
    member(с(_,policeman,POLAGE), С),member(с(_,doctor,DOCAGE), С),POLAGE>DOCAGE,% policeman > doctor 
    member(с(_,engineer,ENGAGE), С),POLAGE>ENGAGE. % policeman > engineer
```

Результатом работы программы является:

```
?- solve(L).
L = [с(dokshin, engineer, 3), с(korneev, doctor, 2), с(skobelev, policeman, 4), с(mareev, baker, 1)] ;
L = [с(dokshin, engineer, 3), с(korneev, doctor, 1), с(skobelev, policeman, 4), с(mareev, baker, 2)] ;
L = [с(dokshin, engineer, 2), с(korneev, doctor, 3), с(skobelev, policeman, 4), с(mareev, baker, 1)] ;
false.
```

Проверим решение на правдоподобность.

Так как пекарь всегда ходит на работу пешком, а Корнеев и Докшин ездят, можно заключить, что фамилия пекаря — не Корнеев и не Докшин. Теперь учтем, что милиционер единственный раз встречался с инженером и не является соседом врача. Отсюда следует, что пара соседей «Корнеев + Докшин» не может быть ни парой «милиционер + врач», ни парой «милиционер + инженер».  Следовательно, Корнеев и Докшин - врач и инженер. Только пока неизвестно, кто из них врач, а кто инженер. Обратим теперь внимание на возрастные данные. С учетом уже сделанных нами выводов и последнего из условий задачи можно сказать, что милиционер старше Корнеева и Докшина.

Здорово! Решения совпадают: лишь возрастное расположение множится. И это не есть противоречие! Посмотрим на информацию о возрастах, что вывел нам предикат:
* S > D > K > M 
* S > D > M > K
* S > K > D > M
Где S - Скобеев, D - Докшин и т.д: противоречий нет.

Что касается сложности: как и было раньше оговорено - все используемые предикаты обладают линейной сложностью. Заключаем, что и предикат solve, их использующий, асимптотически стремится к O(N).

## Выводы

По мере выполнения данной лабораторной работе я освоил многое: закрепил работу со списками, описание предикатов, работающих с ними; наконец, научился решать логические задачи с помощью Пролога.

Возможности Пролога для меня раскрылись во всей красе. С большим интересом мной была написана программа для разрешения такой "нетривиальной" задачи. До этого момента я и представить себе не мог, что существует язык программирования, способный на решение таких емких, описательных задач. 

Однако, полагаю, решение таких простеньких задач проще реализовывать на листочке, от руки. В случае же, если информации в условии задачи очень много, я бы с уверенностью доверил решение оной задачи Прологу. 

