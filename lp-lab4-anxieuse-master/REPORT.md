# Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Короткевич Л. В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

* Примечание от студента: отчет и программа были выполнены и залиты на гитхаб 21 ноября, далее - несущественные правки.

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Основные подходы к обработке естественных и искусственных языков:

* Символьный
* Статистический
* Коннективистский
* Гибридный
* В данный момент нам более интересен символьный подход.

Символьный подход базируется на словарях и правилах, предварительно разработанных людьми. Зачастую представителями символьного подхода являются системы, в основе которых лежат логика и правила. Символьная структура в таких системах представлена в форме логических высказываний. Все преобразования(если они производятся) осуществляются по правилам вывода. Такие системы обычно состоят из набора правил, механизма вывода и рабочей среды. Знания представляются как множество фактов и правил в базе знаний.

Нетрудно заметить схожесть символьного подхода к обработке данных и процесса логического вывода языка Пролог.

К тому же во многих диалектах Пролога встроены средства для удобной работы с DCG-грамматиками (оператор -->). Работа данного оператара основана на разностных списках, которые гораздо производительнее более очевидных реализаций "откусывания" частей предложения с помощью append.

Дале будет показано, что Пролог действительно подходит для анализа текста на естественном языке.

## Задание

Реализовать грамматический разбор фраз на ограниченном естественном языке и преобразовать данные фразы в язык исчисления предикатов первого порядка типа:
```
?-test([every, man, that, lives, loves, a, woman],Res).
Res=all(X,man(X)&lives(X)=>exists(Y,woman(Y)&loves(X,Y)))
```

## Принцип решения

Предложения в любом языке, - гораздо больше, чем просто произвольные последовательности слов. Мы не можем связать вместе какой-либо набор случайных слов и составить разумное предложение. По крайней мере, результат должен соответствовать тому, что мы считаем грамматически верно составленным предложением. 

Грамматика языка - это набор правил, определяющих, какие последовательности слов приемлемы в качестве предложений этого языка. Он определяет, как слова должны группироваться в фразы и какие "порядки" использования этих фраз разрешены. Учитывая грамматику языка, мы можем посмотреть на любую последовательность слов и увидеть, соответствует ли она критериям "приемлемого" предложения. 

Если последовательность слов действительно верно составлена, то процесс проверки установит, что в нем есть какие-либо группы слов, установит их взаимосвязь.

Пример "контексто-свободной" грамматики:\
sentence --> noun_phrase, verb_phrase.\
noun_phrase --> determiner, noun.\
verb_phrase --> verb, noun_phrase.\
verb_phrase --> verb.\
determiner --> [the].\
noun --> [apple].\
noun --> [man].\
verb --> [eats].\
verb --> [sings]. 

Грамматика состоит из набора правил, продемонстрированных выше, по одному в строке. Каждое правило определяет "форму", которую может принять определенный "тип" фразы. Первое правило гласит, что предложение состоит из фразы, называемой noun_phrase, за которой следует фраза, называемая verb_phrase. Эти две фразы являются тем, что обычно называют подлежащим и сказуемым предложения:

![Screenshot](https://i.imgur.com/gKN1aDe.png)

Чтобы понять, что означает правило в контекстно-свободной грамматике, необходимо прочитать X --> Y как выражение "X может принимать форму Y", а "X, Y" - как выражение "X следует за Y". таким образом, первое правило можно прочитать как:

```
Предложение может принимать форму: существительное, за которым следует глагол.
```

Все это очень хорошо, но что такое существительное и что такое глагол? Как же нам распознать такие вещи и узнать, что
составляет для них грамматические формы? На эти вопросы отвечают второе, третье и четвертое правила грамматики. Например,

```
Фраза noun_phrase может иметь вид: определитель, за которым следует noun.
```

Грубо говоря, noun_phrase - это группа слов, которые называют вещь (или вещи). Такая фраза содержит слово, "существительное", которое определяет основной класс, к которому принадлежит вещь. Таким образом, "человек" называет человека, "программа" - программу и так далее. Кроме того, согласно этой грамматике, существительному предшествует фраза, называемая "определитель":

![Screenshot](https://i.imgur.com/c2Ii1hs.png)

Аналогично, внутренняя структура для verb_phrase описывается правилами. Важно заметить, что есть два правила, определяющих, что такое verb_phrase. Всё потому, что есть две возможные формы: глагольная фраза может содержать фразу-существительное, как в "человек ест яблоко", а может и не содержать, как в "человек поет".

Наконец,
```
determiner --> [the].
```
может быть прочитано, как:
```
determiner может принимать вид: слово "the"
```
Теперь, зная всю грамматику, не составит труда описать решение поставленной задачи. 

Определим инфиксные операторы:
```
:- op(900, xfx, =>).
:- op(800, xfy, &).
:- op(300, xfx, :).
```

Разобъем предложение:
```
sentence(P) --> noun_phrase(X, P1, P), verb_phrase(X, P1).
```

Определим noun_phrase, verb_phrase:
```
noun_phrase(X, P1, P) -->
        determiner(X, P2, P1, P), noun(X, P3), rel_clause(X, P3, P2).
noun_phrase(X, P, P) --> name(X).

verb_phrase(X, P) --> trans_verb(X, Y, P1), noun_phrase(Y, P1, P).
verb_phrase(X, P) --> intrans_verb(X, P).
```

Условия "отношения":
```
rel_clause(X, P1, P1&P2) --> [that], verb_phrase(X, P2).
rel_clause(_, P, P) --> [].
```

Определитель "that", "a":
```
determiner(X, P1, P2, all(X):(P1=>P2)) --> [every].
determiner(X, P1, P2, exists(X):(P1&P2)) --> [a].
```

Наконец определим, чем может являться существительное, имя:
```
noun(X, man(X)) --> [man].
noun(X, woman(X)) --> [woman].
name(john) --> [john].
```

Перевод в глаголы:
```
trans_verb(X, Y, loves(X,Y)) --> [loves].
intrans_verb(X, lives(X)) --> [lives].
```

## Результаты

```
?- phrase(sentence(P), [every,man,that,lives,loves,a,woman]).
P = all(X):(man(X)&lives(X)=>exists(Y):(woman(Y)&loves(X, Y))) .
```
```
?- phrase(sentence(P), [john,loves,a,woman]).
P = exists(X):(woman(X)&loves(john, X)) .
```

## Выводы

Благодаря данной лабораторной работе я познакомился с основными принципами обработки естественных языков, реализовал грамматичкский разбор предложения фраз на английском языке, преобразовал их в язык исчисления предикатов первого типа. 

Хотя сам по себе процесс обработки языка довольно широкий и наполненный, в нем присутствует множество нюансов и особенных условий, которые бывает очень сложно реализовать с помощью программного кода; но стоит отметить, что даже с этой задачей Prolog справляется очень хорошо (процесс написания программ для обработки текста занимает не так много сил и времени, если говорить о базовой обработке). Это обусловлено тем, что в используемом мной диалекте языка Пролог встроены удобные средства для работы с DCG-грамматиками. С помощью них предложение представляется как упорядоченный набор частей, с помощью которых довольно лаконично можно описать структуру предложений, а большего для выполнения задачи и не требовалось.

Скромным минусом такого подхода к решению задачи обработки естественных языков на языке Prolog также является наличие необходимости в базе данных, которую, однако, совсем нетрудно описать.

С большим интересом, как любитель дискретной математики, я писал свой вариант данной лабораторной работы, приятно удивляясь возможностям грамматического и синтаксического разбора языка Prolog. Он предлагает совершенно уникальные возможности для решения подобных задач. 

